/* Generated code; do not edit!
   generated by tables/gen.js from imaon2 'f0e220720bbfb8f8e00e76af56806a28fc8739a2'
   https://github.com/comex/imaon2
   arguments: '--gen-hook-disassembler -n _thumb --dis-pattern=P(XXX) out/out-ARM.json'
   (fair warning: at present the main (Rust) code in that repository is barely
    started, embarrassingly so; no need to look at it ;p)
   In case it's copyrightable in any way, consider the generated code in the
   public domain.
*/

/* it_pred_cc_it_mask_mask_1_t2IT: t2IT */
/* GPR_Rm_unk_Rdn_1_tADDhirr: tADDhirr */
/* unk_Rdn_1_tADDrSP: tADDrSP */
/* GPR_Rm_1_tADDspr: tADDspr */
/* t_adrlabel_addr_unk_Rd_1_tADR: tADR */
/* t_brtarget_target_B_1_tB: tB */
/* GPR_func_1_tBLXr: tBLXr */
/* GPR_Rm_B_1_tBX: tBX */
/* t_bcctarget_target_pred_p_B_1_tBcc: tBcc */
/* t_cbtarget_target_B_2_tCBNZ: tCBNZ, tCBZ */
/* tGPR_Rn_reglist_regs_1_tLDMIA: tLDMIA */
/* t_addrmode_pc_addr_unk_Rt_1_tLDRpci: tLDRpci */
/* GPR_Rm_unk_Rd_1_tMOVr: tMOVr */
/* reglist_regs_1_tPOP: tPOP */
/* reglist_regs_S_1_tPUSH: tPUSH */
/* tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD: tSTMIA_UPD */
    switch ((op >> 9) & 0x1f) {
    case 0:
    case 1: {
        if ((op & 0xfffff800) == 0xc000) {
            insn_tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD:;
            struct bitslice regs = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,8}}};
            struct bitslice Rn = {.nruns = 1, .runs = (struct bitslice_run[]) {{8,0,3}}};
            return P(tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD)(ctx, regs, Rn); /* 0x0000c000 | 0x000007ff */
        } else {
            return P(unidentified)(ctx);
        }
    }
    case 2: {
        switch ((op >> 15) & 0x1) {
        case 0: {
            switch ((op >> 3) & 0xf) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15: {
                if ((op & 0xffffff87) == 0x4485) {
                    struct bitslice Rm = {.nruns = 1, .runs = (struct bitslice_run[]) {{3,0,4}}};
                    return P(GPR_Rm_1_tADDspr)(ctx, Rm); /* 0x00004485 | 0x00000078 */
                } else {
                    if ((op & 0xffffff00) == 0x4400) {
                        struct bitslice Rdn = {.nruns = 2, .runs = (struct bitslice_run[]) {{0,0,3}, {7,3,1}}};
                        struct bitslice Rm = {.nruns = 1, .runs = (struct bitslice_run[]) {{3,0,4}}};
                        return P(GPR_Rm_unk_Rdn_1_tADDhirr)(ctx, Rdn, Rm); /* 0x00004400 | 0x000000ff */
                    } else {
                        return P(unidentified)(ctx);
                    }
                }
            }
            case 13: {
                if ((op & 0xffffff78) == 0x4468) {
                    struct bitslice Rdn = {.nruns = 2, .runs = (struct bitslice_run[]) {{0,0,3}, {7,3,1}}};
                    return P(unk_Rdn_1_tADDrSP)(ctx, Rdn); /* 0x00004468 | 0x00000087 */
                } else {
                    return P(unidentified)(ctx);
                }
            }
            }
        }
        case 1: {
            if ((op & 0xfffff800) == 0xc000) {
                goto insn_tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD; /* 0x0000c000 | 0x000007ff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        }
    }
    case 3: {
        switch ((op >> 7) & 0x3) {
        case 0:
        case 1: {
            switch ((op >> 15) & 0x1) {
            case 0: {
                if ((op & 0xffffff00) == 0x4600) {
                    struct bitslice Rd = {.nruns = 2, .runs = (struct bitslice_run[]) {{0,0,3}, {7,3,1}}};
                    struct bitslice Rm = {.nruns = 1, .runs = (struct bitslice_run[]) {{3,0,4}}};
                    return P(GPR_Rm_unk_Rd_1_tMOVr)(ctx, Rd, Rm); /* 0x00004600 | 0x000000ff */
                } else {
                    return P(unidentified)(ctx);
                }
            }
            case 1: {
                if ((op & 0xfffff800) == 0xc000) {
                    goto insn_tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD; /* 0x0000c000 | 0x000007ff */
                } else {
                    return P(unidentified)(ctx);
                }
            }
            }
        }
        case 2: {
            switch ((op >> 15) & 0x1) {
            case 0: {
                if ((op & 0xffffff87) == 0x4700) {
                    struct bitslice Rm = {.nruns = 1, .runs = (struct bitslice_run[]) {{3,0,4}}};
                    return P(GPR_Rm_B_1_tBX)(ctx, Rm); /* 0x00004700 | 0x00000078 */
                } else {
                    return P(unidentified)(ctx);
                }
            }
            case 1: {
                if ((op & 0xfffff800) == 0xc000) {
                    goto insn_tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD; /* 0x0000c000 | 0x000007ff */
                } else {
                    return P(unidentified)(ctx);
                }
            }
            }
        }
        case 3: {
            switch ((op >> 15) & 0x1) {
            case 0: {
                if ((op & 0xffffff87) == 0x4780) {
                    struct bitslice func = {.nruns = 1, .runs = (struct bitslice_run[]) {{3,0,4}}};
                    return P(GPR_func_1_tBLXr)(ctx, func); /* 0x00004780 | 0x00000078 */
                } else {
                    return P(unidentified)(ctx);
                }
            }
            case 1: {
                if ((op & 0xfffff800) == 0xc000) {
                    goto insn_tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD; /* 0x0000c000 | 0x000007ff */
                } else {
                    return P(unidentified)(ctx);
                }
            }
            }
        }
        }
    }
    case 4:
    case 5:
    case 6:
    case 7: {
        switch ((op >> 15) & 0x1) {
        case 0: {
            if ((op & 0xfffff800) == 0x4800) {
                struct bitslice addr = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,8}}};
                struct bitslice Rt = {.nruns = 1, .runs = (struct bitslice_run[]) {{8,0,3}}};
                return P(t_addrmode_pc_addr_unk_Rt_1_tLDRpci)(ctx, addr, Rt); /* 0x00004800 | 0x000007ff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        case 1: {
            if ((op & 0xfffff800) == 0xc800) {
                struct bitslice regs = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,8}}};
                struct bitslice Rn = {.nruns = 1, .runs = (struct bitslice_run[]) {{8,0,3}}};
                return P(tGPR_Rn_reglist_regs_1_tLDMIA)(ctx, regs, Rn); /* 0x0000c800 | 0x000007ff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        }
    }
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
        if ((op & 0xfffff000) == 0xd000) {
            struct bitslice target = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,8}}};
            struct bitslice p = {.nruns = 1, .runs = (struct bitslice_run[]) {{8,0,4}}};
            return P(t_bcctarget_target_pred_p_B_1_tBcc)(ctx, target, p); /* 0x0000d000 | 0x00000fff */
        } else {
            return P(unidentified)(ctx);
        }
    }
    case 16:
    case 17:
    case 18:
    case 19: {
        switch ((op >> 14) & 0x1) {
        case 0: {
            if ((op & 0xfffff800) == 0xa000) {
                struct bitslice addr = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,8}}};
                struct bitslice Rd = {.nruns = 1, .runs = (struct bitslice_run[]) {{8,0,3}}};
                return P(t_adrlabel_addr_unk_Rd_1_tADR)(ctx, addr, Rd); /* 0x0000a000 | 0x000007ff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        case 1: {
            if ((op & 0xfffff800) == 0xe000) {
                struct bitslice target = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,11}}};
                return P(t_brtarget_target_B_1_tB)(ctx, target); /* 0x0000e000 | 0x000007ff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        }
    }
    case 20:
    case 21:
    case 22:
    case 23:
    case 27:
        return P(unidentified)(ctx);
    case 24:
    case 25:
    case 28:
    case 29: {
        if ((op & 0xfffff500) == 0xb100) {
            struct bitslice target = {.nruns = 2, .runs = (struct bitslice_run[]) {{3,0,5}, {9,5,1}}};
            return P(t_cbtarget_target_B_2_tCBNZ)(ctx, target); /* 0x0000b100 | 0x00000aff */
        } else {
            return P(unidentified)(ctx);
        }
    }
    case 26: {
        if ((op & 0xfffffe00) == 0xb400) {
            struct bitslice regs = {.nruns = 2, .runs = (struct bitslice_run[]) {{0,0,8}, {8,14,1}}};
            return P(reglist_regs_S_1_tPUSH)(ctx, regs); /* 0x0000b400 | 0x000001ff */
        } else {
            return P(unidentified)(ctx);
        }
    }
    case 30: {
        if ((op & 0xfffffe00) == 0xbc00) {
            struct bitslice regs = {.nruns = 2, .runs = (struct bitslice_run[]) {{0,0,8}, {8,15,1}}};
            return P(reglist_regs_1_tPOP)(ctx, regs); /* 0x0000bc00 | 0x000001ff */
        } else {
            return P(unidentified)(ctx);
        }
    }
    case 31: {
        if ((op & 0xffffff00) == 0xbf00) {
            struct bitslice mask = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,4}}};
            struct bitslice cc = {.nruns = 1, .runs = (struct bitslice_run[]) {{4,0,4}}};
            return P(it_pred_cc_it_mask_mask_1_t2IT)(ctx, mask, cc); /* 0x0000bf00 | 0x000000ff */
        } else {
            return P(unidentified)(ctx);
        }
    }
    }
/*
static INLINE tdis_ret P(GPR_Rm_1_tADDspr)(struct bitslice ctx, struct bitslice Rm) {}
static INLINE tdis_ret P(GPR_Rm_B_1_tBX)(struct bitslice ctx, struct bitslice Rm) {}
static INLINE tdis_ret P(GPR_Rm_unk_Rd_1_tMOVr)(struct bitslice ctx, struct bitslice Rd, struct bitslice Rm) {}
static INLINE tdis_ret P(GPR_Rm_unk_Rdn_1_tADDhirr)(struct bitslice ctx, struct bitslice Rdn, struct bitslice Rm) {}
static INLINE tdis_ret P(GPR_func_1_tBLXr)(struct bitslice ctx, struct bitslice func) {}
static INLINE tdis_ret P(it_pred_cc_it_mask_mask_1_t2IT)(struct bitslice ctx, struct bitslice mask, struct bitslice cc) {}
static INLINE tdis_ret P(reglist_regs_1_tPOP)(struct bitslice ctx, struct bitslice regs) {}
static INLINE tdis_ret P(reglist_regs_S_1_tPUSH)(struct bitslice ctx, struct bitslice regs) {}
static INLINE tdis_ret P(tGPR_Rn_reglist_regs_1_tLDMIA)(struct bitslice ctx, struct bitslice regs, struct bitslice Rn) {}
static INLINE tdis_ret P(tGPR_Rn_reglist_regs_S_1_tSTMIA_UPD)(struct bitslice ctx, struct bitslice regs, struct bitslice Rn) {}
static INLINE tdis_ret P(t_addrmode_pc_addr_unk_Rt_1_tLDRpci)(struct bitslice ctx, struct bitslice addr, struct bitslice Rt) {}
static INLINE tdis_ret P(t_adrlabel_addr_unk_Rd_1_tADR)(struct bitslice ctx, struct bitslice addr, struct bitslice Rd) {}
static INLINE tdis_ret P(t_bcctarget_target_pred_p_B_1_tBcc)(struct bitslice ctx, struct bitslice target, struct bitslice p) {}
static INLINE tdis_ret P(t_brtarget_target_B_1_tB)(struct bitslice ctx, struct bitslice target) {}
static INLINE tdis_ret P(t_cbtarget_target_B_2_tCBNZ)(struct bitslice ctx, struct bitslice target) {}
static INLINE tdis_ret P(unk_Rdn_1_tADDrSP)(struct bitslice ctx, struct bitslice Rdn) {}
*/

